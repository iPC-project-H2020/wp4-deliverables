---
title: "Molecular entities derived from solid pediatric cancers studied in iPC"
subtitle: "Comparison of methods: unsupervised deconvolution based on stabilized Independent Component Analysis (matrix factorization) (D3.1) and molecular networks (D4.1) "
author: "Jane Merlevede, Marianyela Petrizzelli, Andrei Zinovyev"
date: "`r format(Sys.time(), '%m/%d/%y')`"  
output:
  bookdown::html_document2:
    pandoc_args: [ +RTS, -K14096m, -RTS ]
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    toc_depth: 4
    number_sections: true  
    df_print: paged 
    keep_md: true
    verbose: true
    delete_merged_file: false
    self_contained: FALSE
---
  
```{r variable_definition, echo=FALSE}
#Options to be defined by the user
tumor_type=c("ES", "MB", "NB", "HB")
nPerm=10000 #Nb permutations for gsea
top_top_contributing_genes=10 #Nb of top top_contributing genes to show in table of top_contributing genes
padj_sig_community=10^(-5)
```

```{r file_loading, echo=FALSE} 
#input files to provide 
weighted_metagenes = read.table("input_files/meta_weighted_metagenes", header = TRUE, sep="\t") #computed in D3.1 (mcl_and_weighted_metagenes.R)
datasets_info = read.table("input_files/datasets_info", header = TRUE, sep="\t", as.is=TRUE)     #info about the datasets used in D3.1 (to be provided by the user)
community_comp = read.table("input_files/meta_communities", header = TRUE, sep="\t")            #computed in D3.1 (mcl_and_weighted_metagenes.R)
specific_gene_sets = "input_files/spearman_infered_modules_all_datasets.gmt" #collection of gene sets to be tested for enrichment (obtained from D4.1 using BMNPPSN) as a gmt file
specific_gene_sets_csv = read.csv2("input_files/spearman_infered_modules_all_datasets.csv", sep=";") #the same collection as a csv file
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r package_loading, echo=FALSE, message = FALSE}
library("stringr")
library("knitr")
library("clusterProfiler")
library("GOSemSim")
library("enrichplot")
library("vroom")
library("DOSE")
library("ggplot2")
library("cowplot")
library("DT")
library("stringr")
```


# Introduction
In the framework of D4.3, we investigate if the molecular entities defined in D3.1 and D4.1 are similar. For that, we compare the results of the applications of matrix factorization (D3.1) with the applications of network inference (D4.1) obtained on solid pediatric cancers studied in iPC.  
In D3.1, we performed unsupervised deconvolution using matrix factorization (more precisely stabilized Independent Component Analysis) of gene expression data from the 4 solid tumor types of interest in iPC. We used the results of the meta-analysis performed on gene expression of the solid tumor datasets, using the generated meta-weighted metagenes as defined in D3.1. 

In D4.1, the aim was to build cancer type-specific multi-layered molecular and patient similarity networks. In the context of D4.3, we used the results obtained from the networks derived using Spearman correlation only, to be comparable with what was done in D3.1.

For this comparison, we investigate if some meta-weighted metagenes obtained in D3.1 are related to some subnetworks/modules defined in D4.1. More specifically, we test if the meta-weighted metagenes are enriched in the networks generated by omics layer for each dataset. To this end, the modules deciphered from network analyses in D4.1 were gathered in a gmt file.

This report describes which communities identified in D3.1 from the meta-analysis of the 4 cancer types are retrieved among the networks derived in D4.1. 

The inputs needed to run this analysis are:
  
* the meta weighted metagenes, previously computed in D3.1
* the community composition obtained after the computation of meta weighted metagenes, computed in D3.1
* the information about the datasets used in D3.1
* a gmt file containing the infered networks, obtained from the networks we derived using BMNPPSN R package
* a csv file containing the infered networks


# Description of the molecular networks derived from D4.1 and used as gene sets
To be consistent with what was done in D3.1, we did not use the consensus networks provided in D4.1, as the result of the applications of 10 methods. Instead, we used Spearman correlation only to computing statistical associations between molecular profiles. The only difference compared to what was done in D4.1 is the number of edges used from the input network. Here we kept the 10^4^ highest weights (instead of 10^5^) for computation time reason. To generate the modules derived from one method only (and not from a consensus of methods), we used the R package BMNPPSN on each data type Spearman network (10^4^ highest weighted-edges) on which we detected communities using Markov clustering, allowing the detection of subnetwork / module - signatures. There are in total `r nrow(specific_gene_sets_csv)` modules. 

Let us have a look at the distributions of the number of genes per module, for:

* all modules
* the modules per dataset
* the modules per omics layer

```{r nb_total_modules, echo=FALSE, message=FALSE, warning = FALSE}
nb_genes_in_modules=rep(0,nrow(specific_gene_sets_csv))
for (i in 1:nrow(specific_gene_sets_csv))
{
  nb_genes_in_modules[i] = length(unlist(str_split(specific_gene_sets_csv[i,3],",")))
}

boxplot(nb_genes_in_modules, xlab="all", ylab="Nb of genes in Spearman networks")
summary(nb_genes_in_modules)
```

```{r nb_networks_datasets, echo=FALSE, message=FALSE, warning = FALSE}
datasets = c("Cavalli", "Forget","Henrich", "Postel-Vinay")
nb_networks_per_dataset=c(0,ncol=length(datasets))
nb_genes_in_modules_datasets=matrix(0,nrow=nrow(specific_gene_sets_csv), ncol=length(datasets))

for (d in 1: length(datasets))
{
  data = specific_gene_sets_csv[grep(datasets[d],specific_gene_sets_csv[,1]),]
  for (i in 1:nrow(data))
  {
    nb_genes_in_modules_datasets[i,d] = length(unlist(str_split(data[i,3],",")))
  }
  nb_networks_per_dataset[d]=nrow(data)
}

nb_genes_in_modules_datasets[nb_genes_in_modules_datasets == 0] <- NA
```

There are in total `r nb_networks_per_dataset` (`r datasets`) modules per dataset.

```{r nb_networks_datasets_plots, echo=FALSE, message=FALSE, warning = FALSE}
boxplot(x = as.list(as.data.frame(nb_genes_in_modules_datasets)), names=datasets, ylab="Nb of genes in Spearman networks")
summary(nb_genes_in_modules_datasets)
```

```{r nb_networks_layer, echo=FALSE, message=FALSE, warning = FALSE}
layers = c("GE","methylation", "proteomics", "phosphoprot")
nb_genes_in_modules_layers=matrix(0,nrow=nrow(specific_gene_sets_csv), ncol=length(layers))
nb_networks_per_layer=c(0,ncol=length(datasets))

for (d in 1: length(layers))
{
  data = specific_gene_sets_csv[grep(layers[d],specific_gene_sets_csv[,1], ignore.case = FALSE),]
  for (i in 1:nrow(data))
  {
    nb_genes_in_modules_layers[i,d] = length(unlist(str_split(data[i,3],",")))
  }
  nb_networks_per_layer[d] = nrow(data)
}

nb_genes_in_modules_layers[nb_genes_in_modules_layers == 0] <- NA
```

There are in total `r nb_networks_per_layer` (`r layers`) modules per omics layer.

```{r nb_networks_layer_plots, echo=FALSE, message=FALSE, warning = FALSE}
boxplot(x = as.list(as.data.frame(nb_genes_in_modules_layers)), subset = nb_genes_in_modules_layers>0, names=layers, ylab="Nb of genes in Spearman networks")
summary(nb_genes_in_modules_layers)
```


# Enrichment analysis of the communities in the gene sets derived from the molecular networks 
Now we check if the communities defined in D3.1 are enriched in the molecular networks identified in the scope of D4.1, where 3 tumor types where investigated: MB (Cavalli and Forget datasets), ES (Postel-Vinay dataset) and NB (Henrich dataset). For that, we performed over representation analysis of the top-contributing genes of the positive and negative tails of each community using the defined gene sets.

```{r communities_enrichment_modules, echo=FALSE, message=FALSE, warning = FALSE, include=FALSE}
sgs <- read.gmt(specific_gene_sets)
egmt_pos_communities=data.frame(matrix(nrow=0,ncol=10))
egmt_neg_communities=data.frame(matrix(nrow=0,ncol=10))

Mean=colMeans(weighted_metagenes, na.rm = TRUE)
SD=apply(weighted_metagenes,2,sd, na.rm = TRUE)
out_sgs <- NULL

for (i in 1:nrow(community_comp))
{
  out_sgs <- c(out_sgs, knit_child('template_enrichment_in_modules.Rmd', quiet = TRUE))
}
egmt_pos_communities = egmt_pos_communities[,c(10,1,9,3:8,12,11)]
egmt_neg_communities = egmt_neg_communities[,c(10,1,9,3:8,12,11)]
```

```{r communities_enrichment_modules_datatable, echo=FALSE, message=FALSE, warning = FALSE}
datatable(egmt_pos_communities, rownames = FALSE, caption="\n\n\nEnrichment in user defined gene sets for top-contributing genes (pos tail)", escape=FALSE)
datatable(egmt_neg_communities, rownames = FALSE, caption="\n\n\nEnrichment in user defined gene sets for top-contributing genes (neg tail)", escape=FALSE)

egmt_pos_communities_GE=egmt_pos_communities[grep("_GE_",egmt_pos_communities$ID),]
egmt_neg_communities_GE=egmt_neg_communities[grep("_GE_",egmt_neg_communities$ID),]
egmt_pos_communities_Prot=egmt_pos_communities[grep("_proteomics_",egmt_pos_communities$ID),]
egmt_neg_communities_Prot=egmt_neg_communities[grep("_proteomics_",egmt_neg_communities$ID),]
egmt_pos_communities_Phosphoprot=egmt_pos_communities[grep("_phosphoprot_",egmt_pos_communities$ID),]
egmt_neg_communities_Phosphoprot=egmt_neg_communities[grep("_phosphoprot_",egmt_neg_communities$ID),]
egmt_pos_communities_Methyl=egmt_pos_communities[grep("_methylation_",egmt_pos_communities$ID),]
egmt_neg_communities_Methyl=egmt_neg_communities[grep("_methylation_",egmt_neg_communities$ID),]
```
For each community, a total of `r length(unique(sgs$term))` gene sets are tested. 

There are a total of `r nrow(egmt_pos_communities)` significant enrichments in positive tails and `r nrow(egmt_neg_communities)` significant enrichment in negative tails. More specifically, there are a total of:

* `r nrow(egmt_pos_communities_GE)` (`r length(unique(egmt_pos_communities_GE$ID))` unique) significant enrichments "GE" in positive tails and `r nrow(egmt_neg_communities_GE)` (`r length(unique(egmt_neg_communities_GE$ID))` unique) significant enrichments "GE" in negative tails.

* `r nrow(egmt_pos_communities_Methyl)` (`r length(unique(egmt_pos_communities_Methyl$ID))` unique) significant enrichments "Methylation" in positive tails and `r nrow(egmt_neg_communities_Methyl)` (`r length(unique(egmt_neg_communities_Methyl$ID))` unique) significant enrichments "Methylation" in negative tails.

* `r nrow(egmt_pos_communities_Prot)` (`r length(unique(egmt_pos_communities_Prot$ID))` unique) significant enrichments "Proteomics" in positive tails and `r nrow(egmt_neg_communities_Prot)` (`r length(unique(egmt_neg_communities_Prot$ID))` unique) significant enrichments "Proteomics" in negative tails.

* `r nrow(egmt_pos_communities_Phosphoprot)` (`r length(unique(egmt_pos_communities_Phosphoprot$ID))` unique) significant enrichments "Phosphoproteomics" in positive tails and `r nrow(egmt_neg_communities_Phosphoprot)` (`r length(unique(egmt_neg_communities_Phosphoprot$ID))` unique) significant enrichments "Phosphoproteomics" in negative tails.


```{r enriched_communities, echo=FALSE} 
#compute the nb of unique enriched communities
egmt_pos_communities$tail="pos"
enriched_pos_communities = unique(egmt_pos_communities$Community)
egmt_neg_communities$tail="neg"
enriched_neg_communities = unique(egmt_neg_communities$Community)
enriched_communities = unique(c(enriched_pos_communities, enriched_neg_communities))
```
There are `r length(enriched_communities)` communities showing enrichements in modules with padj below 10^-2^.


# Identification of the most significant communities

## Keep only highly significantly enriched communities
First, we required a higly significant adjusted p value to further consider a community. We chose 10^-5^.
```{r sign_communities, echo=FALSE}
#identify the communities with highly significant enrichments in the modules
ind_sig_pos = which(egmt_pos_communities$p.adjust<padj_sig_community )
egmt_pos_communities_sig = egmt_pos_communities[ind_sig_pos,]
sig_pos_communities = unique(egmt_pos_communities_sig$Community)

ind_sig_neg = which(egmt_neg_communities$p.adjust<padj_sig_community )
egmt_neg_communities_sig = egmt_neg_communities[ind_sig_neg,]
sig_neg_communities = unique(egmt_neg_communities_sig$Community)

sig_communities = unique(c(sig_pos_communities, sig_neg_communities))
```
Based on this threshold, there are `r length(ind_sig_pos)` positive significant enrichments and `r length(ind_sig_neg)` negative significant enrichments, which correspond to `r length(sig_communities)` communities.

## Exclusion of communities with enrichments in ribosomal or immunoglobulin genes 
Next, we excluded communities with annotations related to ribosome and immunoglobuline.

### Exclusion of "ribosomal" communities
```{r exclude_ribosome_communities, echo=FALSE}
ind_to_be_excluded_pos=c()
ind_to_be_excluded_neg=c()

pos_sig_enrichments = egmt_pos_communities_sig
for (i in 1:nrow(egmt_pos_communities_sig ))
{
  gene_enriched = unlist(strsplit(pos_sig_enrichments$geneID[i],"/"))
  if ( length(grep("^RPL", gene_enriched)) / length(gene_enriched) >0.1 || length(grep("^RPS", gene_enriched)) / length(gene_enriched) >0.1 )
  {
    #remove all enrichments from these communities
    community_to_be_excluded = pos_sig_enrichments$Community[i]
    current_ind_to_be_excluded = which(pos_sig_enrichments$Community==community_to_be_excluded)
    ind_to_be_excluded_pos = c(ind_to_be_excluded_pos, current_ind_to_be_excluded)
  }
}

neg_sig_enrichments = egmt_neg_communities_sig
for (i in 1:nrow(egmt_neg_communities_sig ))
{
  gene_enriched = unlist(strsplit(neg_sig_enrichments$geneID[i],"/"))
  if ( length(grep("^RPL", gene_enriched))/ length(gene_enriched)  >0.1 || length(grep("^RPS", gene_enriched)) / length(gene_enriched) >0.1 )
  {
    #remove all enrichments from these communities
    community_to_be_excluded = neg_sig_enrichments$Community[i]
    current_ind_to_be_excluded = which(neg_sig_enrichments$Community==community_to_be_excluded)
    ind_to_be_excluded_neg = c(ind_to_be_excluded_neg, current_ind_to_be_excluded)
  }
}

pos_sig_enrichments = pos_sig_enrichments[-ind_to_be_excluded_pos,]
neg_sig_enrichments = neg_sig_enrichments[-ind_to_be_excluded_neg,]

cleaned_r_pos_communities = unique(pos_sig_enrichments$Community)
cleaned_r_neg_communities = unique(neg_sig_enrichments$Community)
cleaned_r_communities = unique(c(cleaned_r_pos_communities, cleaned_r_neg_communities))
```

After excluding communities where more than 10% of the enrichments are "RPL/S*" genes, there are `r nrow(pos_sig_enrichments)` positive significant enrichments and `r nrow(neg_sig_enrichments)` negative significant enrichments, which correspond to `r length(cleaned_r_communities)` communities with enriched modules having padj below 10^-5^.

### Exclusion of "HLA" communities
```{r exclude_immunoglobuline_communities, echo=FALSE}
ind_to_be_excluded_pos=c()
ind_to_be_excluded_neg=c()

pos_sig_enrichments_cleaned = pos_sig_enrichments
for (i in 1:nrow(pos_sig_enrichments ))
{
  gene_enriched = unlist(strsplit(pos_sig_enrichments$geneID[i],"/"))
  if ( length(grep("^HLA",gene_enriched)) / length(gene_enriched) >0.2  )
  {
    #remove all enrichments from these communities
    community_to_be_excluded = pos_sig_enrichments$Community[i]
    current_ind_to_be_excluded = which(pos_sig_enrichments$Community==community_to_be_excluded)
    ind_to_be_excluded_pos = c(ind_to_be_excluded_pos, current_ind_to_be_excluded)
  }
}

neg_sig_enrichments_cleaned = neg_sig_enrichments
for (i in 1:nrow(neg_sig_enrichments ))
{
  gene_enriched = unlist(strsplit(pos_sig_enrichments$geneID[i],"/"))
  if ( length( grep("^HLA", gene_enriched)) / length(gene_enriched) >0.2  )
  {
    #remove all enrichments from these communities
    community_to_be_excluded = neg_sig_enrichments$Community[i]
    current_ind_to_be_excluded = which(neg_sig_enrichments$Community==community_to_be_excluded)
    ind_to_be_excluded_neg = c(ind_to_be_excluded_neg, current_ind_to_be_excluded)
  }
}

pos_sig_enrichments_cleaned = pos_sig_enrichments_cleaned[-ind_to_be_excluded_pos,]
neg_sig_enrichments_cleaned = neg_sig_enrichments_cleaned[-ind_to_be_excluded_neg,]

cleaned_pos_communities = unique(pos_sig_enrichments_cleaned$Community)
cleaned_neg_communities = unique(neg_sig_enrichments_cleaned$Community)
cleaned_communities = unique(c(cleaned_pos_communities, cleaned_neg_communities))

community_comp_cleaned = community_comp
rownames(community_comp_cleaned)=paste0("C",rownames(community_comp))
ind_community_comp_cleaned = which(rownames(community_comp_cleaned) %in% cleaned_communities)
community_comp_cleaned = community_comp_cleaned[ind_community_comp_cleaned,]
```

After excluding communities where more than 20% of the enrichments are "HLA*" genes, there are `r nrow(pos_sig_enrichments_cleaned)` positive significant enrichments and `r nrow(neg_sig_enrichments_cleaned)` negative significant enrichments, which correspond to `r length(cleaned_communities)` communities with enriched modules having padj below 10^-5^:

```{r print_cleaned_communities, echo=FALSE}
datatable(pos_sig_enrichments_cleaned, rownames = FALSE, caption="\n\n\nEnrichment for top-contributing genes (pos tail) of the most significant communities", escape=FALSE)
datatable(neg_sig_enrichments_cleaned, rownames = FALSE, caption="\n\n\nEnrichment for top-contributing genes (neg tail) of the most significant communities", escape=FALSE)
```


# Description of the most significant communities

## Community composition
We first look at the number of components and at the components themselves per community for the `r nrow(community_comp_cleaned)` identified communities having significant enrichments (p.adjust<10^-5^) in at least one of the modules.
```{r table_cleaned_community_composition, echo=FALSE}
barplot(rowSums(!is.na(community_comp_cleaned)), xlab="Community", ylab="Nb of components", main="Nb of components per significant community", names.arg = rownames(community_comp_cleaned))
datatable(community_comp_cleaned)
```

## Nature of these communities
Then, for each of these communities, we describe how many components they contain, from how many unique datatsets they come from and report the number of tumor types demonstrating this signal. 
We also show how many bulk and single cell data were gathered. The sample type, like patients, cell lines, PDX, controls... is also given.

Next, we indicate which tail of the community is significantly enriched and we mention which subnetwork.s is.are enriched.

All this information provide a first clue for the interpretation and allow to select specific communities according to the reader interest to go deeper into the description.

```{r compute_cleaned_community_info, echo=FALSE} 
community_stats=as.data.frame(matrix(0, nrow = nrow(community_comp_cleaned), ncol = 0))
community_stats$community=rownames(community_comp_cleaned)
community_stats$nb_comp = rowSums(!is.na(community_comp_cleaned))

for (c in 1:nrow(community_comp_cleaned))
{
  current_community = community_comp_cleaned[c,!is.na(community_comp_cleaned[c,])]
  comp_name=rep(0,length(current_community))
  for (k in 1:length(current_community))
  {
    comp_name[k] = unlist(str_split(current_community[1,k],"_metagene"))[1]
  }
  
  ind_comp_current_community = which(datasets_info$Acronym %in% comp_name)
  datasets_info_current_community = datasets_info[ind_comp_current_community,]
  
  community_stats$nb_comp_unique[c] = length(unique(comp_name))
  tumors=which( unique(datasets_info_current_community$tumor_type) %in% tumor_type)
  community_stats$nb_tumor_type[c] = length(tumors)
  community_stats$tumor_type[c] = paste0( unique(datasets_info_current_community$tumor_type)[unique(datasets_info_current_community$tumor_type) %in% tumor_type], collapse = ",")
  community_stats$nb_bulk[c]= sum(datasets_info_current_community$Techno=="bulk")
  community_stats$nb_sc[c]= sum(datasets_info_current_community$Techno=="single-cell")
  community_stats$nb_patient[c] = sum(datasets_info_current_community$data_type=="Patient")
  community_stats$nb_PDX[c] = sum(datasets_info_current_community$data_type=="PDX")
  community_stats$nb_cell_line[c] = sum(datasets_info_current_community$data_type=="cell-line")
  community_stats$nb_control[c] = sum(datasets_info_current_community$data_type=="control")  
  community_stats$nb_adult[c] = length(grep("_adults", datasets_info_current_community$Acronym) )  
  
  if ( community_stats$community[c] %in% pos_sig_enrichments$Community)
  {
    community_stats$sig_tail[c] = "pos"
  }
  if ( community_stats$community[c] %in% neg_sig_enrichments$Community)
  {
    community_stats$sig_tail[c] = "neg"
  }
  if ( (community_stats$community[c] %in% pos_sig_enrichments$Community) && ( community_stats$community[c] %in% neg_sig_enrichments$Community) )
  {
    community_stats$sig_tail[c] = "pos;neg"
  }
  
  ind_pos=which(pos_sig_enrichments$Community %in% community_stats$community[c])
  ind_neg=which(neg_sig_enrichments$Community %in% community_stats$community[c])
  
  if ( length(ind_pos) ==1 )
  {
    community_stats$enriched_modules[c] = pos_sig_enrichments$Module[ind_pos]
  } else if(length(ind_pos) >1 )
  {
    community_stats$enriched_modules[c] = paste0(pos_sig_enrichments$Module[ind_pos], collapse = ",")
  }
  
  if ( length(ind_neg) ==1 )
  {
    community_stats$enriched_modules[c] = neg_sig_enrichments$Module[ind_neg]
  } else if(length(ind_neg) >1 )
  {
    community_stats$enriched_modules[c] = paste0(neg_sig_enrichments$Module[ind_neg], collapse = ",")
  }
  
  if ( length(ind_pos) >0 & length(ind_neg) >0 )
  {
    community_stats$enriched_modules[c] = paste( paste0(pos_sig_enrichments$Module[ind_pos], collapse = ","), paste0(neg_sig_enrichments$Module[ind_neg], collapse = ","), sep = ";")
  }
  
}
kable(community_stats)
write.table(community_stats, "community_stats.txt", sep="\t", quote=FALSE, row.names=FALSE)
```

```{r compute_cleaned_community_info_to_be_mentioned_in_text, echo=FALSE, message=FALSE, warning=FALSE} 
nb_bulk_only=length(which(community_stats$nb_sc == 0))
nb_sc_only=length(which(community_stats$nb_bulk == 0))
nb_no_control=length(which(community_stats$nb_control == 0))
nb_no_adult=length(which(community_stats$nb_adult == 0))
```

`r nrow(community_stats)-nb_bulk_only-nb_sc_only` out of `r nrow(community_stats)` communities are a mixture of bulk and single cell data, `r nb_bulk_only` contain only bulk and `r nb_sc_only` contain only single cell datasets. `r nb_no_control` out of `r nrow(community_stats)` communities do not contain any control. If one is interested in tumor related signals, we can look in particular at communities containing no component from control datasets. If one wants to explore mechanisms found only in children, we can exclude commnunities containing components coming from adult datasets.

## Top-contributing genes
The `r top_top_contributing_genes` top-contributing genes are shown below for each community. Top-contributing genes of a community are the genes whose weights are below or beyond 3 sd from the mean of the weigths in this community.
```{r prepare_table_top_contributing_genes, echo=FALSE, message=FALSE, warning=FALSE}
#for each weighted metagenes of interest, the top contributing genes are the genes beyond 3 SD from the mean
Mean=colMeans(weighted_metagenes, na.rm = TRUE)
SD=apply(weighted_metagenes,2,sd, na.rm = TRUE)
  
nb_pos_tail_3SD=nb_neg_tail_3SD=rep(0,ncol(weighted_metagenes))
scores_pos_tail_3SD=scores_neg_tail_3SD=rep(0,ncol(weighted_metagenes))
fn = "meta_top_contributing_genes"
invisible(file.remove(fn))
  
for (k in 1:ncol(weighted_metagenes))
{
  ind_pos_tail_3SD=which(weighted_metagenes[,k]>Mean[k]+3*SD[k])
  ind_neg_tail_3SD=which(weighted_metagenes[,k]<Mean[k]-3*SD[k])
  genes_pos_tail= rownames(weighted_metagenes[ind_pos_tail_3SD,])
  genes_neg_tail= rownames(weighted_metagenes[ind_neg_tail_3SD,])
  genes=c(genes_pos_tail, genes_neg_tail)
  scores=c(weighted_metagenes[ind_pos_tail_3SD,k], weighted_metagenes[ind_neg_tail_3SD,k])
  top_contributing_genes=data.frame(cbind(paste0("C",k), genes, scores))
  write.table(top_contributing_genes , "meta_top_contributing_genes", sep="\t", row.names = FALSE, append=TRUE, 
              col.names=!file.exists( tumor_type,"meta_top_contributing_genes"), quote=FALSE)
}
```

```{r table_top_contributing_genes, echo=FALSE, message=FALSE, warning=FALSE}
top_contributing_genes = read.table("meta_top_contributing_genes", header = TRUE, sep="\t", as.is=TRUE)
table_top_contributing_genes=data.frame(Community=numeric(nrow(community_comp_cleaned)), top_top_contrib_genes_pos_tail=numeric(nrow(community_comp_cleaned)), top_top_contrib_genes_neg_tail=numeric(nrow(community_comp_cleaned)))
for (i in 1:nrow(community_comp_cleaned))
{
  community = subset(top_contributing_genes, V1==rownames(community_comp_cleaned)[i])
  community_pos = community[which(community$scores>=0),]
  community_neg = community[which(community$scores<0),]  
  community_pos = community_pos[order(community_pos$scores,decreasing=TRUE),]
  community_neg = community_neg[order(community_neg$scores,decreasing=FALSE),]
    
  table_top_contributing_genes$Community[i] <- rownames(community_comp_cleaned)[i]
  
  #check which tail is significant
  pos_tail = which(egmt_pos_communities_sig$Community == table_top_contributing_genes$Community[i])
  neg_tail = which(egmt_neg_communities_sig$Community == table_top_contributing_genes$Community[i])
  
  if ( length(pos_tail)>0 )
  {
    table_top_contributing_genes$top_top_contrib_genes_pos_tail[i] = paste0(community_pos$genes[1:top_top_contributing_genes], collapse=";")
  }

  if (length(neg_tail)>0 )
  {
    table_top_contributing_genes$top_top_contrib_genes_neg_tail[i] = paste0(community_neg$genes[1:top_top_contributing_genes], collapse=";")
  }  
}
datatable(table_top_contributing_genes, rownames=FALSE)
write.table(table_top_contributing_genes, "table_top_contributing_genes.txt", sep="\t", quote=FALSE, row.names=FALSE)
```

## Annotation of the communities using GO
Finally, we describe each community in details, trying to decipher the underlying mechanism. We extracted the top-contributing genes in each community and performed over representation analysis as well as gene set enrichment analyses on the enriched tail.s of each community using GO. Results are represented in tables, as well as in dotplots, cnetplots and emaplots for both drivers of the positive and negative tails using clusterProfiler (https://bookdown.org/yihui/rmarkdown/html-document.html). If the OR analysis had no enrichment in one or the two tails, no plot are reported.

```{r communities_enrichment_details, echo=FALSE, message=FALSE, warning = FALSE,fig.fullwidth = TRUE, fig.width=12}
folder_MSigDB_gene_sets = "../../../GSEA/gmt_files/MSigDB/"
gene_sets = list.files(folder_MSigDB_gene_sets, full.names = TRUE)
d <- godata('org.Hs.eg.db', ont="BP")
  
out_community_GO <- NULL
top_enrichments = as.data.frame(matrix(nrow=nrow(community_comp_cleaned), ncol=2))
for (j in 1:nrow(community_comp_cleaned))
{
  out_community_GO <- c(out_community_GO, knit_child('template_enrichment_in_GO.Rmd', quiet = TRUE))
}
```

`r paste(out_community_GO, collapse='\n')`


# Molecular entities identified by independent methods 
In the final table below, we summarized all the information collected for each community, linking the annotations obtained in both work, D3.1 and D4.1, to facilitate the comparison.

```{r final_lists, echo=FALSE, message=FALSE, warning=FALSE}
#we add the annotations to community_stats
for (c in 1:nrow(community_comp_cleaned))
{
  ind_pos=which(pos_sig_enrichments$Community %in% community_stats$community[c])
  ind_neg=which(neg_sig_enrichments$Community %in% community_stats$community[c])
  
  #if the positive tail of the community is enriched in one or more module.s:
  if ( length(ind_pos)==1 )
  {
    community_stats$module_annotations[c] = pos_sig_enrichments$Annotation[ind_pos]
  } else if(length(ind_pos) >1 )
  {
    community_stats$module_annotations[c] = paste0(pos_sig_enrichments$Annotation[ind_pos], collapse = " - ")
  }
  
  #if the negative tail of the community is enriched in one or more module.s:
  if ( length(ind_neg)==1 )
  {
    community_stats$module_annotations[c] = neg_sig_enrichments$Annotation[ind_neg]
  } else if(length(ind_neg) >1 )
  {
    community_stats$module_annotations[c] = paste0(neg_sig_enrichments$Annotation[ind_neg], collapse = " - ")
  }

  #if both tails of the community are enriched in one or more module.s:
  if ( length(ind_pos) >0 & length(ind_neg) >0 )
  {
    community_stats$module_annotations[c] = paste( paste0(pos_sig_enrichments$Annotation[ind_pos], collapse = " - "), paste0(neg_sig_enrichments$Annotation[ind_neg], collapse = " - "), sep = ";")
  }
  
  community_stats$GO_annotations[c] = paste(top_enrichments[c,1], top_enrichments[c,2], sep = " ; ")
}
write.table(community_stats, "community_complete_description.txt", sep="\t", quote=FALSE, row.names=FALSE)

datatable(community_stats)
```